{
  "version": 3,
  "sources": ["../src/workers/upload/types/messages.ts", "../src/workers/upload/logger.ts", "../src/lib/errors.ts", "../src/workers/upload/config.ts", "../src/workers/upload/apiClient.ts", "../src/workers/upload/databaseService.ts", "../src/workers/upload/uploadHandler.ts", "../src/workers/upload/utils.ts", "../src/workers/upload/worker.ts"],
  "sourcesContent": ["import {\n  ChunkConfig,\n  ResumeData,\n  RetryConfig,\n  UploadState,\n  UploadStatus,\n  WorkerErrorDetails,\n} from \"./uploadManagement\";\n\n// ====================\n// Inbound Messages\n// ====================\n\nexport type WorkerInboundMessage =\n  | StartUploadMessage\n  | ResumeUploadMessage\n  | PauseUploadMessage\n  | CancelUploadMessage\n  | GetUploadStatusMessage\n  | GetActiveUploadsMessage\n  | HeartbeatMessage;\n\nexport interface StartUploadMessage {\n  type: \"START_UPLOAD\";\n  file: File;\n  duration: number;\n  fileType: string;\n  retryConfig?: RetryConfig;\n  chunkConfig?: ChunkConfig;\n}\n\nexport interface ResumeUploadMessage {\n  type: \"RESUME_UPLOAD\";\n  contentId: string;\n}\n\nexport interface PauseUploadMessage {\n  type: \"PAUSE_UPLOAD\";\n  contentId: string;\n}\n\nexport interface CancelUploadMessage {\n  type: \"CANCEL_UPLOAD\";\n  contentId: string;\n}\n\nexport interface GetUploadStatusMessage {\n  type: \"GET_UPLOAD_STATUS\";\n  contentId: string;\n}\n\nexport interface GetActiveUploadsMessage {\n  type: \"GET_ACTIVE_UPLOADS\";\n}\n\nexport interface HeartbeatMessage {\n  type: \"HEARTBEAT\";\n}\n\n// ====================\n// Outbound Messages\n// ====================\n\nexport type WorkerOutboundMessage =\n  | UploadProgressMessage\n  | UploadCompleteMessage\n  | UploadErrorMessage\n  | UploadPausedMessage\n  | UploadCancelledMessage\n  | UploadStatusMessage\n  | ChunkUploadedMessage\n  | RetryingChunkMessage\n  | InitiateUploadResponseMessage\n  | LogMessage\n  | UploadsUpdateMessage;\n\nexport interface UploadProgressMessage {\n  type: \"UPLOAD_PROGRESS\";\n  contentId: string;\n  progress: number;\n  uploadedBytes: number;\n  totalBytes: number;\n  uploadSpeed?: number; // bytes per second\n  timeRemaining?: number; // seconds\n  activeConnections?: number;\n}\n\nexport interface UploadCompleteMessage {\n  type: \"UPLOAD_COMPLETE\";\n  contentId: string;\n  fileUrl: string;\n  duration: number; // total upload time in ms\n  totalBytes: number;\n  averageSpeed: number; // bytes per second\n}\n\nexport interface UploadErrorMessage {\n  type: \"UPLOAD_ERROR\";\n  contentId: string;\n  error: WorkerErrorDetails;\n}\n\nexport interface UploadPausedMessage {\n  type: \"UPLOAD_PAUSED\";\n  contentId: string;\n  resumeData: ResumeData;\n}\n\nexport interface UploadCancelledMessage {\n  type: \"UPLOAD_CANCELLED\";\n  contentId: string;\n  reason?: string;\n}\n\nexport interface UploadStatusMessage {\n  type: \"UPLOAD_STATUS\";\n  contentId: string;\n  status: UploadStatus | { status: \"not_found\" };\n}\n\nexport interface ChunkUploadedMessage {\n  type: \"CHUNK_UPLOADED\";\n  contentId: string;\n  partNumber: number;\n  size: number;\n}\n\nexport interface RetryingChunkMessage {\n  type: \"RETRYING_CHUNK\";\n  contentId: string;\n  partNumber: number;\n  attempt: number;\n  maxAttempts: number;\n  error: string;\n  nextAttemptDelay: number;\n}\n\nexport interface InitiateUploadResponseMessage {\n  type: \"INITIATE_UPLOAD_RESPONSE\";\n  contentId: string;\n  uploadId: string;\n  key: string;\n}\n\nexport interface LogMessage {\n  type: \"LOG\";\n  contentId?: string;\n  message: string;\n  level?: \"info\" | \"warn\" | \"error\";\n}\n\nexport interface UploadsUpdateMessage {\n  type: \"UPLOADS_UPDATE\";\n  uploads: UploadState[];\n}\n\n// ====================\n// Type Guards\n// ====================\n\nexport function isWorkerInboundMessage(\n  message: unknown\n): message is WorkerInboundMessage {\n  return (\n    typeof message === \"object\" &&\n    message !== null &&\n    \"type\" in message &&\n    typeof (message as { type: string }).type === \"string\" &&\n    [\n      \"START_UPLOAD\",\n      \"PAUSE_UPLOAD\",\n      \"RESUME_UPLOAD\",\n      \"CANCEL_UPLOAD\",\n      \"GET_UPLOAD_STATUS\",\n      \"GET_ACTIVE_UPLOADS\",\n      \"HEARTBEAT\",\n    ].includes((message as { type: string }).type)\n  );\n}\n\nexport function isWorkerOutboundMessage(\n  message: unknown\n): message is WorkerOutboundMessage {\n  return (\n    typeof message === \"object\" &&\n    message !== null &&\n    \"type\" in message &&\n    typeof (message as { type: string }).type === \"string\" &&\n    [\n      \"UPLOAD_PROGRESS\",\n      \"UPLOAD_COMPLETE\",\n      \"UPLOAD_ERROR\",\n      \"UPLOAD_PAUSED\",\n      \"UPLOAD_CANCELLED\",\n      \"UPLOAD_STATUS\",\n      \"CHUNK_UPLOADED\",\n      \"RETRYING_CHUNK\",\n      \"INITIATE_UPLOAD_RESPONSE\",\n      \"LOG\",\n    ].includes((message as { type: string }).type)\n  );\n}\n", "import { LogMessage, WorkerOutboundMessage } from \"./types\";\n\ndeclare const self: ServiceWorkerGlobalScope;\n\nexport function broadcastLog(\n  message: string,\n  level: \"info\" | \"warn\" | \"error\" = \"info\",\n  contentId?: string\n) {\n  const logMessage: LogMessage = {\n    type: \"LOG\",\n    contentId,\n    message,\n    level,\n  };\n  broadcast(logMessage);\n}\n\nexport function broadcast(message: WorkerOutboundMessage): void {\n  void self.clients.matchAll().then((clients) => {\n    clients.forEach((client) => client.postMessage(message));\n  });\n}\n", "/**\n * Base class for custom errors in the application.\n */\nexport class AppError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = this.constructor.name;\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = new Error(message).stack;\n    }\n  }\n}\n\n/**\n * Represents an error that can be retried.\n */\nexport class RetryableError extends AppError {\n  constructor(\n    message: string,\n    public readonly code?: string,\n    public readonly details?: unknown // Using unknown instead of any\n  ) {\n    super(message);\n  }\n}\n\n/**\n * Represents a fatal error that cannot be recovered from.\n */\nexport class FatalError extends AppError {\n  constructor(\n    message: string,\n    public readonly code?: string,\n    public readonly details?: unknown // Using unknown instead of any\n  ) {\n    super(message);\n  }\n}\n\n/**\n * Represents an error related to the upload process.\n */\nexport class UploadError extends AppError {\n  constructor(\n    message: string,\n    public readonly partNumber?: number,\n    public readonly uploadId?: string\n  ) {\n    super(message);\n  }\n}\n\n/**\n * Represents an error related to the API.\n */\nexport class ApiError extends AppError {\n  constructor(\n    message: string,\n    public readonly statusCode: number,\n    public readonly responseBody?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * Represents an error related to the database operations.\n */\nexport class DatabaseError extends AppError {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly details?: unknown\n  ) {\n    super(message);\n  }\n}\n\n/**\n * Utility function to determine if an error is retryable.\n */\nexport function isRetryableError(error: unknown): boolean {\n  return (\n    error instanceof RetryableError ||\n    (error instanceof ApiError &&\n      [500, 502, 503, 504].includes(error.statusCode))\n  );\n}\n", "export const CONFIG = {\n  // Maximum size of each part in bytes (e.g., 10MB)\n  PART_SIZE: 10 * 1024 * 1024,\n\n  // Maximum number of concurrent part uploads\n  MAX_CONCURRENT_UPLOADS: 5,\n\n  // Base time window for speed calculation in milliseconds (e.g., 5 seconds)\n  SPEED_CALCULATION_WINDOW: 5000,\n\n  // Base URL for API endpoints\n  API_BASE_URL: \"/api\",\n\n  // Timeout for API calls in milliseconds (e.g., 3 minutes)\n  API_TIMEOUT: 180000,\n\n  // Maximum file size allowed for upload in bytes (e.g., 10GB)\n  MAX_FILE_SIZE: 10 * 1024 * 1024 * 1024,\n\n  // Allowed file types for upload\n  ALLOWED_FILE_TYPES: [\"video/mp4\", \"video/quicktime\", \"video/x-msvideo\"],\n\n  // IndexedDB database configuration\n  DATABASE: {\n    NAME: \"UploadDB\",\n    VERSION: 1,\n  },\n\n  // Speed tracking configuration\n  SPEED_TRACKING: {\n    // Minimum data points required for speed calculation\n    MIN_DATA_POINTS: 3,\n\n    // Maximum data points to keep for speed calculation\n    MAX_DATA_POINTS: 20,\n\n    // Interval for speed updates in milliseconds\n    UPDATE_INTERVAL: 1000,\n\n    // Weight for exponential moving average (0-1)\n    EMA_WEIGHT: 0.3,\n  },\n\n  // Retry configuration\n  RETRY: {\n    // Number of retry attempts for failed API calls\n    ATTEMPTS: 3,\n\n    // Delay between retry attempts in milliseconds\n    DELAY: 1000,\n\n    // Maximum time to wait between retries in milliseconds\n    MAX_DELAY: 30000,\n\n    // Jitter range for retry delays (\u00B120%)\n    JITTER_FACTOR: 0.2,\n\n    // HTTP status codes that should trigger a retry\n    STATUS_CODES: [408, 429, 500, 502, 503, 504],\n\n    // Network error types that should trigger a retry\n    ERROR_TYPES: [\"NetworkError\", \"TimeoutError\", \"AbortError\", \"UploadError\"],\n  },\n\n  // S3 Transfer Acceleration configuration\n  S3_TRANSFER_ACCELERATION: {\n    ENABLED: true,\n\n    // Minimum file size to use acceleration (e.g., 512MB)\n    MIN_SIZE: 512 * 1024 * 1024,\n\n    // Default acceleration endpoint\n    DEFAULT_ENDPOINT: \"s3-accelerate.amazonaws.com\",\n  },\n};\n", "// apiClient.ts\n\nimport {\n  CompleteMultipartUploadResponse,\n  InitiateUploadResponse,\n  SignedUrlResponse,\n  UploadPart,\n} from \"./types\";\nimport { FatalError, RetryableError } from \"@/lib/errors\";\n\nimport { CONFIG } from \"./config\";\n\nexport class ApiClient {\n  private baseUrl: string;\n  private timeout: number;\n  private accelerationEndpoint: string | null = null;\n\n  constructor(baseUrl: string, timeout: number) {\n    this.baseUrl = baseUrl;\n    this.timeout = timeout;\n  }\n\n  /**\n   * Initiates a multipart upload session.\n   */\n  async initiateMultipartUpload(\n    file: File,\n    videoDuration: number,\n    fileType: string\n  ): Promise<InitiateUploadResponse> {\n    const useAcceleration = this.shouldUseAcceleration(file.size);\n\n    const response = await this.fetchWithRetry(\n      `${this.baseUrl}/upload/multipart/initiate`,\n      {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          fileName: file.name,\n          fileType,\n          size: file.size,\n          duration: videoDuration,\n          useAcceleration,\n        }),\n      }\n    );\n\n    if (!response.ok) {\n      throw new FatalError(\"Failed to initiate multipart upload\");\n    }\n\n    const data = (await response.json()) as InitiateUploadResponse;\n\n    if (data.accelerationEndpoint) {\n      this.accelerationEndpoint = data.accelerationEndpoint;\n    }\n\n    return data;\n  }\n\n  /**\n   * Gets a signed URL for uploading a specific part.\n   */\n  async getSignedUrl(\n    partNumber: number,\n    uploadId: string,\n    key: string\n  ): Promise<string> {\n    const response = await this.fetchWithRetry(\n      `${this.baseUrl}/upload/multipart/signed-url`,\n      {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          partNumber,\n          uploadId,\n          key,\n          useAcceleration: !!this.accelerationEndpoint,\n        }),\n      }\n    );\n\n    if (!response.ok) {\n      throw new RetryableError(\"Failed to get signed URL\");\n    }\n\n    const data = (await response.json()) as SignedUrlResponse;\n    return data.signedUrl;\n  }\n\n  /**\n   * Uploads a single part of the file to S3.\n   */\n  async uploadPart(\n    key: string,\n    uploadId: string,\n    partNumber: number,\n    chunk: Blob,\n    abortSignal: AbortSignal\n  ): Promise<UploadPart> {\n    const signedUrl = await this.getSignedUrl(partNumber, uploadId, key);\n    const uploadUrl = this.transformToAcceleratedUrl(signedUrl);\n\n    const response = await this.fetchWithRetry(\n      uploadUrl,\n      {\n        method: \"PUT\",\n        body: chunk,\n        headers: {\n          \"Content-Type\": \"application/octet-stream\",\n          \"Content-Length\": chunk.size.toString(),\n        },\n      },\n      CONFIG.RETRY.ATTEMPTS,\n      abortSignal\n    );\n\n    if (!response.ok) {\n      throw new RetryableError(`Failed to upload part ${partNumber}`);\n    }\n\n    const eTag = response.headers.get(\"ETag\");\n    if (!eTag) {\n      throw new Error(`No ETag received for part ${partNumber}`);\n    }\n\n    return {\n      partNumber,\n      eTag: eTag.replace(/\"/g, \"\"),\n      size: chunk.size,\n    };\n  }\n\n  /**\n   * Completes the multipart upload session.\n   */\n  async completeMultipartUpload(\n    key: string,\n    uploadId: string,\n    contentId: string,\n    parts: UploadPart[]\n  ): Promise<CompleteMultipartUploadResponse> {\n    const response = await this.fetchWithRetry(\n      `${this.baseUrl}/upload/multipart/complete`,\n      {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          key,\n          uploadId,\n          contentId,\n          parts,\n          useAcceleration: !!this.accelerationEndpoint,\n        }),\n      }\n    );\n\n    if (!response.ok) {\n      throw new FatalError(\"Failed to complete multipart upload\");\n    }\n\n    const data = (await response.json()) as CompleteMultipartUploadResponse;\n    return data;\n  }\n\n  /**\n   * Cancels the multipart upload session.\n   */\n  async cancelUpload(\n    key: string,\n    uploadId: string,\n    contentId: string\n  ): Promise<void> {\n    const response = await this.fetchWithRetry(\n      `${this.baseUrl}/upload/multipart/cancel`,\n      {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          key,\n          uploadId,\n          contentId,\n          useAcceleration: !!this.accelerationEndpoint,\n        }),\n      }\n    );\n\n    if (!response.ok) {\n      throw new RetryableError(\"Failed to cancel multipart upload\");\n    }\n  }\n\n  /**\n   * Lists the parts that have been uploaded so far.\n   */\n  async listUploadedParts(\n    key: string,\n    uploadId: string\n  ): Promise<UploadPart[]> {\n    const response = await this.fetchWithRetry(\n      `${this.baseUrl}/upload/multipart/list-parts`,\n      {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          key,\n          uploadId,\n        }),\n      }\n    );\n\n    if (!response.ok) {\n      throw new RetryableError(\"Failed to list uploaded parts\");\n    }\n\n    const data = (await response.json()) as { parts: UploadPart[] };\n    return data.parts;\n  }\n\n  // ====================\n  // Private Helper Methods\n  // ====================\n\n  /**\n   * Determines whether to use S3 Transfer Acceleration based on file size.\n   */\n  private shouldUseAcceleration(fileSize: number): boolean {\n    return (\n      CONFIG.S3_TRANSFER_ACCELERATION.ENABLED &&\n      fileSize >= CONFIG.S3_TRANSFER_ACCELERATION.MIN_SIZE\n    );\n  }\n\n  /**\n   * Transforms a standard S3 URL to an accelerated URL if applicable.\n   */\n  private transformToAcceleratedUrl(url: string): string {\n    if (!this.accelerationEndpoint) {\n      return url;\n    }\n\n    return url.replace(\n      /\\.s3\\.([^.]+)\\.amazonaws\\.com/,\n      `.${this.accelerationEndpoint}`\n    );\n  }\n\n  /**\n   * Combines multiple AbortSignals into one.\n   */\n  private combineAbortSignals(\n    signals: (AbortSignal | undefined)[]\n  ): AbortSignal {\n    const controller = new AbortController();\n\n    signals.forEach((signal) => {\n      if (signal) {\n        if (signal.aborted) {\n          controller.abort();\n        } else {\n          signal.addEventListener(\"abort\", () => controller.abort());\n        }\n      }\n    });\n\n    return controller.signal;\n  }\n\n  /**\n   * Fetch with timeout and optional abort signal.\n   */\n  private async fetchWithTimeout(\n    url: string,\n    options: RequestInit,\n    abortSignal?: AbortSignal\n  ): Promise<Response> {\n    const controller = new AbortController();\n    const signal = this.combineAbortSignals([controller.signal, abortSignal]);\n    const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n    try {\n      const response = await fetch(url, { ...options, signal });\n      clearTimeout(timeoutId);\n      return response;\n    } catch (error) {\n      clearTimeout(timeoutId);\n      if (error instanceof DOMException && error.name === \"AbortError\") {\n        throw new RetryableError(\"Request timed out\");\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch with retry logic for retryable errors.\n   */\n  private async fetchWithRetry(\n    url: string,\n    options: RequestInit,\n    retries: number = CONFIG.RETRY.ATTEMPTS,\n    abortSignal?: AbortSignal\n  ): Promise<Response> {\n    try {\n      return await this.fetchWithTimeout(url, options, abortSignal);\n    } catch (error) {\n      if (retries > 0 && error instanceof RetryableError) {\n        await new Promise((resolve) => setTimeout(resolve, CONFIG.RETRY.DELAY));\n        return this.fetchWithRetry(url, options, retries - 1, abortSignal);\n      }\n      throw error;\n    }\n  }\n}\n", "// databaseService.ts\n\nimport { UploadChunk, UploadState } from \"./types\";\n\nimport { broadcastLog } from \"./logger\";\n\nconst DB_CONFIG = {\n  name: \"UploadServiceWorkerDB\",\n  version: 1,\n  stores: {\n    uploads: \"uploads\",\n    chunks: \"chunks\",\n    metadata: \"metadata\",\n  },\n};\n\nclass DatabaseService {\n  private dbPromise: Promise<IDBDatabase> | null = null;\n\n  /**\n   * Opens a connection to the IndexedDB database, creating object stores if necessary.\n   */\n  private openDatabase(): Promise<IDBDatabase> {\n    if (this.dbPromise) {\n      return this.dbPromise;\n    }\n\n    this.dbPromise = new Promise((resolve, reject) => {\n      const request = indexedDB.open(DB_CONFIG.name, DB_CONFIG.version);\n\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n\n        if (!db.objectStoreNames.contains(DB_CONFIG.stores.uploads)) {\n          db.createObjectStore(DB_CONFIG.stores.uploads, { keyPath: \"id\" });\n        }\n\n        if (!db.objectStoreNames.contains(DB_CONFIG.stores.chunks)) {\n          const chunkStore = db.createObjectStore(DB_CONFIG.stores.chunks, {\n            keyPath: \"id\",\n          });\n          chunkStore.createIndex(\"uploadId\", \"uploadId\", { unique: false });\n        }\n\n        if (!db.objectStoreNames.contains(DB_CONFIG.stores.metadata)) {\n          db.createObjectStore(DB_CONFIG.stores.metadata, { keyPath: \"id\" });\n        }\n      };\n    });\n\n    return this.dbPromise;\n  }\n\n  /**\n   * Wraps an IndexedDB request in a Promise for easier async/await usage.\n   */\n  private promisifyRequest<T>(request: IDBRequest<T>): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  /**\n   * Saves the upload state to the IndexedDB database.\n   */\n  async saveUploadState(state: UploadState): Promise<void> {\n    broadcastLog(\n      `Saving upload state for contentId: ${state.contentId}`,\n      \"info\"\n    );\n    try {\n      const db = await this.openDatabase();\n      const transaction = db.transaction(\n        [DB_CONFIG.stores.uploads],\n        \"readwrite\"\n      );\n      const store = transaction.objectStore(DB_CONFIG.stores.uploads);\n      await this.promisifyRequest(store.put(state));\n      broadcastLog(\n        `Successfully saved upload state for contentId: ${state.contentId}`,\n        \"info\"\n      );\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error\";\n      broadcastLog(\n        `Error saving upload state: ${errorMessage}`,\n        \"error\",\n        state.contentId\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Loads the upload state from the IndexedDB database.\n   */\n  async loadUploadState(id: string): Promise<UploadState | undefined> {\n    broadcastLog(`Loading upload state for id: ${id}`, \"info\");\n    try {\n      const db = await this.openDatabase();\n      const transaction = db.transaction(\n        [DB_CONFIG.stores.uploads],\n        \"readonly\"\n      );\n      const store = transaction.objectStore(DB_CONFIG.stores.uploads);\n      const result = await this.promisifyRequest<UploadState | undefined>(\n        store.get(id)\n      );\n      broadcastLog(`Successfully loaded upload state for id: ${id}`, \"info\");\n      return result;\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error\";\n      broadcastLog(`Error loading upload state: ${errorMessage}`, \"error\", id);\n      throw error;\n    }\n  }\n\n  /**\n   * Saves an upload chunk to the IndexedDB database.\n   */\n  async saveChunk(chunk: UploadChunk): Promise<void> {\n    try {\n      const db = await this.openDatabase();\n      const transaction = db.transaction(\n        [DB_CONFIG.stores.chunks],\n        \"readwrite\"\n      );\n      const store = transaction.objectStore(DB_CONFIG.stores.chunks);\n      await this.promisifyRequest(store.put(chunk));\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Loads all chunks associated with a specific upload ID.\n   */\n  async loadChunks(uploadId: string): Promise<UploadChunk[]> {\n    try {\n      const db = await this.openDatabase();\n      const transaction = db.transaction([DB_CONFIG.stores.chunks], \"readonly\");\n      const store = transaction.objectStore(DB_CONFIG.stores.chunks);\n      const index = store.index(\"uploadId\");\n      const result = await this.promisifyRequest(index.getAll(uploadId));\n      return result;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Deletes the upload state from the IndexedDB database.\n   */\n  async deleteUploadState(contentId: string): Promise<void> {\n    try {\n      const db = await this.openDatabase();\n      const transaction = db.transaction(\n        [DB_CONFIG.stores.uploads],\n        \"readwrite\"\n      );\n      const store = transaction.objectStore(DB_CONFIG.stores.uploads);\n      await this.promisifyRequest(store.delete(contentId));\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Deletes all chunks associated with a specific upload ID.\n   */\n  async deleteChunks(uploadId: string): Promise<void> {\n    try {\n      const db = await this.openDatabase();\n      const transaction = db.transaction(\n        [DB_CONFIG.stores.chunks],\n        \"readwrite\"\n      );\n      const store = transaction.objectStore(DB_CONFIG.stores.chunks);\n      const index = store.index(\"uploadId\");\n      const cursorRequest = index.openKeyCursor(IDBKeyRange.only(uploadId));\n\n      await new Promise<void>((resolve, reject) => {\n        cursorRequest.onerror = () => reject(cursorRequest.error);\n        cursorRequest.onsuccess = (event) => {\n          const cursor = (event.target as IDBRequest<IDBCursor>).result;\n          if (cursor) {\n            store.delete(cursor.primaryKey);\n            cursor.continue();\n          } else {\n            resolve();\n          }\n        };\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Loads all upload states from the IndexedDB database.\n   */\n  async loadAllUploadStates(): Promise<UploadState[]> {\n    try {\n      const db = await this.openDatabase();\n      const transaction = db.transaction(\n        [DB_CONFIG.stores.uploads],\n        \"readonly\"\n      );\n      const store = transaction.objectStore(DB_CONFIG.stores.uploads);\n      const result = await this.promisifyRequest(store.getAll());\n      return result;\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n\nexport const databaseService = new DatabaseService();\n", "// uploadHandler.ts\n\nimport {\n  ChunkUploadedMessage,\n  ResumeUploadMessage,\n  RetryingChunkMessage,\n  StartUploadMessage,\n  UploadCancelledMessage,\n  UploadCompleteMessage,\n  UploadErrorMessage,\n  UploadPart,\n  UploadPausedMessage,\n  UploadProgressMessage,\n  UploadState,\n  UploadStatusMessage,\n  WorkerOutboundMessage,\n} from \"./types\";\nimport { broadcast, broadcastLog } from \"./logger\";\n\nimport { ApiClient } from \"./apiClient\";\nimport { CONFIG } from \"./config\";\nimport { RetryableError } from \"@/lib/errors\";\nimport { databaseService } from \"./databaseService\";\n\n// Map to keep track of active uploads\nconst activeUploads = new Map<string, ActiveUpload>();\n\ninterface ActiveUpload {\n  state: UploadState;\n  controller: AbortController;\n}\n\nexport class UploadHandler {\n  private apiClient: ApiClient;\n\n  constructor() {\n    this.apiClient = new ApiClient(CONFIG.API_BASE_URL, CONFIG.API_TIMEOUT);\n  }\n\n  /**\n   * Loads ongoing uploads from the database and resumes them if necessary.\n   */\n  async loadOngoingUploads(): Promise<void> {\n    const allUploadStates = await databaseService.loadAllUploadStates();\n    for (const state of allUploadStates) {\n      if (state.status === \"in_progress\") {\n        await this.resumeUpload(state);\n      }\n    }\n  }\n\n  /**\n   * Handles the upload process for START_UPLOAD and RESUME_UPLOAD messages.\n   */\n  async handleUpload(\n    message: StartUploadMessage | ResumeUploadMessage\n  ): Promise<void> {\n    let uploadState: UploadState;\n\n    if (message.type === \"RESUME_UPLOAD\") {\n      uploadState = await this.getUploadStateForResume(message.contentId);\n    } else {\n      uploadState = await this.initializeNewUpload(message);\n    }\n\n    if (!uploadState.contentId) {\n      throw new Error(\"Upload state has no contentId\");\n    }\n\n    // Set up upload tracking\n    const controller = new AbortController();\n    activeUploads.set(uploadState.contentId, {\n      state: uploadState,\n      controller,\n    });\n\n    await databaseService.saveUploadState(uploadState);\n\n    // Proceed with uploading parts\n    await this.uploadParts(uploadState, controller.signal);\n  }\n\n  /**\n   * Initializes a new upload and returns the upload state.\n   */\n  private async initializeNewUpload(\n    message: StartUploadMessage\n  ): Promise<UploadState> {\n    const { file, duration, fileType, chunkConfig } = message;\n    const contentId = crypto.randomUUID();\n\n    broadcastLog(`Starting upload for contentId: ${contentId}`, \"info\");\n\n    // Initiate upload\n    const { uploadId, key, content } =\n      await this.apiClient.initiateMultipartUpload(file, duration, fileType);\n\n    broadcast({\n      type: \"INITIATE_UPLOAD_RESPONSE\",\n      contentId,\n      uploadId,\n      key,\n    } as WorkerOutboundMessage);\n\n    const partSize = chunkConfig?.size ?? CONFIG.PART_SIZE;\n    const maxConcurrentUploads =\n      chunkConfig?.concurrent ?? CONFIG.MAX_CONCURRENT_UPLOADS;\n\n    const uploadState: UploadState = {\n      id: content.id,\n      file,\n      fileName: file.name,\n      fileSize: file.size,\n      uploadId,\n      key,\n      progress: 0,\n      status: \"in_progress\",\n      parts: [],\n      startTime: Date.now(),\n      contentId: content.id,\n      partSize,\n      maxConcurrentUploads,\n    };\n\n    return uploadState;\n  }\n\n  /**\n   * Retrieves the upload state for a resume operation.\n   */\n  private async getUploadStateForResume(\n    contentId: string\n  ): Promise<UploadState> {\n    const state = await databaseService.loadUploadState(contentId);\n    if (!state) {\n      throw new Error(\"No upload state found to resume\");\n    }\n\n    broadcastLog(`Resuming upload with uploadId: ${state.uploadId}`, \"info\");\n    return state;\n  }\n\n  /**\n   * Uploads the parts of the file.\n   */\n  private async uploadParts(\n    uploadState: UploadState,\n    abortSignal: AbortSignal\n  ): Promise<void> {\n    const { file, key, uploadId, contentId, partSize } = uploadState;\n\n    if (!contentId) {\n      throw new Error(\"Upload state has no contentId\");\n    }\n\n    const totalParts = Math.ceil(file.size / partSize);\n    broadcastLog(`Total parts to upload: ${totalParts}`, \"info\");\n\n    // Retrieve list of already uploaded parts\n    const uploadedParts = await this.getUploadedParts(uploadState);\n\n    const uploadedPartNumbers = new Set(\n      uploadedParts.map((part) => part.partNumber)\n    );\n    let completedParts = uploadedParts.length;\n\n    // Upload remaining parts\n    for (let partNumber = 1; partNumber <= totalParts; partNumber++) {\n      if (uploadedPartNumbers.has(partNumber)) {\n        broadcastLog(`Skipping already uploaded part ${partNumber}`, \"info\");\n        continue;\n      }\n\n      const start = (partNumber - 1) * partSize;\n      const end = Math.min(start + partSize, file.size);\n      const chunk = file.slice(start, end);\n\n      try {\n        const part = await this.uploadPart(\n          contentId,\n          key,\n          uploadId,\n          partNumber,\n          chunk,\n          abortSignal\n        );\n\n        uploadState.parts.push(part);\n        completedParts++;\n\n        const progress = Math.round((completedParts / totalParts) * 100);\n        uploadState.progress = progress;\n\n        await databaseService.saveUploadState(uploadState);\n        this.broadcastProgress(\n          contentId,\n          progress,\n          completedParts,\n          uploadState\n        );\n      } catch (error) {\n        await this.handleUploadError(contentId, error);\n        throw error; // Stop uploading on error\n      }\n    }\n\n    // Complete the upload\n    await this.completeUpload(uploadState);\n  }\n\n  /**\n   * Retrieves the list of uploaded parts from the API.\n   */\n  private async getUploadedParts(\n    uploadState: UploadState\n  ): Promise<UploadPart[]> {\n    try {\n      const parts = await this.apiClient.listUploadedParts(\n        uploadState.key,\n        uploadState.uploadId\n      );\n      broadcastLog(`Retrieved ${parts.length} uploaded parts`, \"info\");\n      return parts;\n    } catch (error) {\n      broadcastLog(\n        `Failed to retrieve uploaded parts: ${(error as Error).message}`,\n        \"error\"\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Uploads a single part of the file.\n   */\n  private async uploadPart(\n    contentId: string,\n    key: string,\n    uploadId: string,\n    partNumber: number,\n    chunk: Blob,\n    abortSignal: AbortSignal,\n    retryCount = 0\n  ): Promise<UploadPart> {\n    try {\n      const part = await this.apiClient.uploadPart(\n        key,\n        uploadId,\n        partNumber,\n        chunk,\n        abortSignal\n      );\n\n      broadcast({\n        type: \"CHUNK_UPLOADED\",\n        contentId,\n        partNumber,\n        size: chunk.size,\n      } as ChunkUploadedMessage);\n\n      return {\n        partNumber,\n        eTag: part.eTag,\n        size: chunk.size,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error\";\n\n      if (\n        retryCount < CONFIG.RETRY.ATTEMPTS &&\n        error instanceof RetryableError &&\n        !(error instanceof DOMException && error.name === \"AbortError\")\n      ) {\n        const delay = Math.min(1000 * Math.pow(2, retryCount), 30000);\n\n        broadcast({\n          type: \"RETRYING_CHUNK\",\n          contentId,\n          partNumber,\n          attempt: retryCount + 1,\n          maxAttempts: CONFIG.RETRY.ATTEMPTS,\n          error: errorMessage,\n          nextAttemptDelay: delay,\n        } as RetryingChunkMessage);\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        return this.uploadPart(\n          contentId,\n          key,\n          uploadId,\n          partNumber,\n          chunk,\n          abortSignal,\n          retryCount + 1\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Broadcasts upload progress to the main thread.\n   */\n  private broadcastProgress(\n    contentId: string,\n    progress: number,\n    completedParts: number,\n    uploadState: UploadState\n  ): void {\n    const message: UploadProgressMessage = {\n      type: \"UPLOAD_PROGRESS\",\n      contentId,\n      progress,\n      uploadedBytes: completedParts * uploadState.partSize,\n      totalBytes: uploadState.fileSize,\n    };\n\n    broadcast(message);\n  }\n\n  /**\n   * Completes the upload process.\n   */\n  private async completeUpload(uploadState: UploadState): Promise<void> {\n    const { contentId, key, uploadId, parts, startTime, fileSize } =\n      uploadState;\n\n    if (!contentId) {\n      throw new Error(\"Upload state has no contentId\");\n    }\n\n    broadcastLog(`Completing upload for contentId: ${contentId}`, \"info\");\n\n    const completeResponse = await this.apiClient.completeMultipartUpload(\n      key,\n      uploadId,\n      contentId,\n      parts\n    );\n\n    uploadState.status = \"completed\";\n    uploadState.fileUrl = completeResponse.location;\n    await databaseService.saveUploadState(uploadState);\n\n    broadcast({\n      type: \"UPLOAD_COMPLETE\",\n      contentId,\n      fileUrl: completeResponse.location,\n      duration: Date.now() - startTime,\n      totalBytes: fileSize,\n      averageSpeed: fileSize / (Date.now() - startTime),\n    } as UploadCompleteMessage);\n\n    activeUploads.delete(contentId);\n    broadcastLog(`Upload completed for contentId: ${contentId}`, \"info\");\n  }\n\n  /**\n   * Handles errors during the upload process.\n   */\n  private async handleUploadError(\n    contentId: string,\n    error: unknown\n  ): Promise<void> {\n    const errorMessage =\n      error instanceof Error ? error.message : \"Unknown error\";\n    const isRetryable = error instanceof RetryableError;\n\n    broadcast({\n      type: \"UPLOAD_ERROR\",\n      contentId,\n      error: {\n        code: \"UPLOAD_FAILED\",\n        message: errorMessage,\n        retryable: isRetryable,\n      },\n    } as UploadErrorMessage);\n\n    const upload = activeUploads.get(contentId);\n    if (upload) {\n      upload.state.status = \"error\";\n      upload.state.error = errorMessage;\n      await databaseService.saveUploadState(upload.state);\n      activeUploads.delete(contentId);\n    }\n  }\n\n  /**\n   * Pauses an ongoing upload.\n   */\n  async handlePause(contentId: string): Promise<void> {\n    const upload = activeUploads.get(contentId);\n    if (!upload) return;\n\n    upload.controller.abort();\n    upload.state.status = \"paused\";\n    await databaseService.saveUploadState(upload.state);\n\n    broadcast({\n      type: \"UPLOAD_PAUSED\",\n      contentId,\n    } as UploadPausedMessage);\n\n    activeUploads.delete(contentId);\n  }\n\n  /**\n   * Resumes a paused upload.\n   */\n  async handleResume(contentId: string): Promise<void> {\n    try {\n      const uploadState = await databaseService.loadUploadState(contentId);\n      if (!uploadState || uploadState.status !== \"paused\") {\n        broadcastLog(\n          `No paused upload found for contentId: ${contentId}`,\n          \"error\"\n        );\n        return;\n      }\n\n      uploadState.status = \"in_progress\";\n      await databaseService.saveUploadState(uploadState);\n\n      await this.handleUpload({ type: \"RESUME_UPLOAD\", contentId });\n    } catch (error) {\n      await this.handleUploadError(contentId, error);\n    }\n  }\n\n  /**\n   * Cancels an ongoing upload.\n   */\n  async handleCancel(contentId: string): Promise<void> {\n    const upload = activeUploads.get(contentId);\n    if (!upload) return;\n\n    upload.controller.abort();\n\n    await databaseService.deleteUploadState(contentId);\n    await databaseService.deleteChunks(upload.state.uploadId);\n\n    try {\n      await this.apiClient.cancelUpload(\n        upload.state.key,\n        upload.state.uploadId,\n        contentId\n      );\n      broadcastLog(\n        `Successfully cancelled upload for contentId: ${contentId}`,\n        \"info\"\n      );\n    } catch (error) {\n      broadcastLog(\n        `Error cancelling upload for contentId: ${contentId}: ${\n          (error as Error).message\n        }`,\n        \"error\"\n      );\n    }\n\n    broadcast({\n      type: \"UPLOAD_CANCELLED\",\n      contentId,\n    } as UploadCancelledMessage);\n\n    activeUploads.delete(contentId);\n  }\n\n  /**\n   * Handles GET_ACTIVE_UPLOADS message.\n   */\n  async handleGetActiveUploads(): Promise<void> {\n    const uploads = await databaseService.loadAllUploadStates();\n\n    for (const upload of uploads) {\n      if (upload.status === \"in_progress\" || upload.status === \"paused\") {\n        await this.resumeUpload(upload);\n        broadcast({\n          type: \"UPLOAD_STATUS\",\n          contentId: upload.contentId,\n          status: upload.status,\n        } as UploadStatusMessage);\n      }\n    }\n  }\n\n  /**\n   * Handles GET_UPLOAD_STATUS message.\n   */\n  async handleGetUploadStatus(contentId: string): Promise<void> {\n    const state = await databaseService.loadUploadState(contentId);\n    if (state) {\n      broadcast({\n        type: \"UPLOAD_STATUS\",\n        contentId,\n        status: state.status,\n      } as UploadStatusMessage);\n    } else {\n      broadcast({\n        type: \"UPLOAD_STATUS\",\n        contentId,\n        status: \"not_found\",\n      } as UploadStatusMessage);\n    }\n  }\n\n  /**\n   * Resumes an upload using the existing upload state.\n   */\n  private async resumeUpload(uploadState: UploadState): Promise<void> {\n    const contentId = uploadState.contentId;\n    if (!contentId) {\n      throw new Error(\"Upload state has no contentId\");\n    }\n    if (activeUploads.has(contentId)) {\n      // Upload is already in progress\n      return;\n    }\n\n    const controller = new AbortController();\n    activeUploads.set(contentId, { state: uploadState, controller });\n\n    await this.uploadParts(uploadState, controller.signal);\n  }\n\n  /**\n   * Resumes all paused uploads.\n   */\n  public async resumeAllUploads(): Promise<void> {\n    const allUploadStates = await databaseService.loadAllUploadStates();\n    for (const state of allUploadStates) {\n      if (state.status === \"paused\" || state.status === \"in_progress\") {\n        await this.resumeUpload(state);\n      }\n    }\n  }\n}\n", "// eventListenerUtils.ts (Updated)\n\ninterface WorkerEventMap {\n  install: ExtendableEvent;\n  activate: ExtendableEvent;\n  online: Event;\n  message: ExtendableMessageEvent;\n  // Add other event types as needed\n}\n\nexport type EventHandler<K extends keyof WorkerEventMap> = (\n  event: WorkerEventMap[K]\n) => void;\n\n/**\n * A generic utility to add event listeners with type safety.\n * @param target The event target (e.g., self in Service Worker).\n * @param type The event type.\n * @param handler The event handler.\n */\nexport function addTypedEventListener<K extends keyof WorkerEventMap>(\n  target: EventTarget,\n  type: K,\n  handler: EventHandler<K>\n): void {\n  target.addEventListener(type, handler as EventListener);\n}\n", "// serviceWorker.ts\n\n/// <reference lib=\"webworker\" />\n\nimport { WorkerOutboundMessage, isWorkerInboundMessage } from \"./types\";\n\nimport { UploadHandler } from \"./uploadHandler\";\nimport { addTypedEventListener } from \"./utils\";\nimport { broadcastLog } from \"./logger\";\n\ndeclare const self: ServiceWorkerGlobalScope;\n\n// Initialize the UploadHandler\nconst uploadHandler = new UploadHandler();\n\n/**\n * Handles incoming messages with type safety.\n * @param event The message event from the main thread.\n */\nconst handleMessage = async (event: ExtendableMessageEvent) => {\n  const data = event.data;\n\n  // Type guard to ensure data is a WorkerInboundMessage\n  if (!isWorkerInboundMessage(data)) {\n    broadcastLog(\"Invalid message received\", \"error\");\n    return;\n  }\n\n  const message = data;\n\n  const contentId = \"contentId\" in message ? message.contentId : undefined;\n  broadcastLog(`Received message: ${message.type}`, \"info\", contentId);\n\n  try {\n    switch (message.type) {\n      case \"START_UPLOAD\":\n        await uploadHandler.handleUpload(message);\n        break;\n      case \"PAUSE_UPLOAD\":\n        await uploadHandler.handlePause(message.contentId);\n        break;\n      case \"RESUME_UPLOAD\":\n        await uploadHandler.handleResume(message.contentId);\n        break;\n      case \"CANCEL_UPLOAD\":\n        await uploadHandler.handleCancel(message.contentId);\n        break;\n      case \"GET_UPLOAD_STATUS\":\n        await uploadHandler.handleGetUploadStatus(message.contentId);\n        break;\n      case \"GET_ACTIVE_UPLOADS\":\n        await uploadHandler.handleGetActiveUploads();\n        break;\n      case \"HEARTBEAT\":\n        break;\n      default:\n        const exhaustiveCheck: never = message;\n        broadcastLog(\n          `Unhandled message type: ${JSON.stringify(exhaustiveCheck)}`,\n          \"warn\",\n          contentId\n        );\n    }\n  } catch (error) {\n    const workerError = error as WorkerOutboundMessage & { contentId?: string };\n\n    broadcastLog(\n      `Error handling message ${message.type}: ${\n        \"message\" in workerError ? workerError.message : \"Unexpected error\"\n      }`,\n      \"error\",\n      workerError.contentId\n    );\n  }\n};\n\n// Install event\naddTypedEventListener(self, \"install\", (event) => {\n  console.log(\"Service Worker installing.\");\n  event.waitUntil(self.skipWaiting()); // Activate worker immediately\n});\n\n// Activate event\naddTypedEventListener(self, \"activate\", (event) => {\n  console.log(\"Service Worker activating.\");\n  event.waitUntil(uploadHandler.loadOngoingUploads());\n});\n\n// Online event\naddTypedEventListener(self, \"online\", () => {\n  void uploadHandler.resumeAllUploads();\n});\n\n// Message event with improved type safety\naddTypedEventListener(self, \"message\", handleMessage);\n"],
  "mappings": "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",
  "names": ["isWorkerInboundMessage", "message", "broadcastLog", "message", "level", "contentId", "broadcast", "clients", "client", "AppError", "message", "RetryableError", "code", "details", "FatalError", "CONFIG", "ApiClient", "baseUrl", "timeout", "__publicField", "file", "videoDuration", "fileType", "useAcceleration", "response", "FatalError", "data", "partNumber", "uploadId", "key", "RetryableError", "chunk", "abortSignal", "signedUrl", "uploadUrl", "CONFIG", "eTag", "contentId", "parts", "fileSize", "url", "signals", "controller", "signal", "options", "timeoutId", "error", "retries", "resolve", "DB_CONFIG", "DatabaseService", "__publicField", "resolve", "reject", "request", "event", "db", "state", "broadcastLog", "store", "error", "errorMessage", "id", "result", "chunk", "uploadId", "index", "contentId", "cursorRequest", "cursor", "databaseService", "activeUploads", "UploadHandler", "__publicField", "ApiClient", "CONFIG", "allUploadStates", "databaseService", "state", "message", "uploadState", "controller", "file", "duration", "fileType", "chunkConfig", "contentId", "broadcastLog", "uploadId", "key", "content", "broadcast", "partSize", "maxConcurrentUploads", "abortSignal", "totalParts", "uploadedParts", "uploadedPartNumbers", "part", "completedParts", "partNumber", "start", "end", "chunk", "progress", "error", "parts", "retryCount", "errorMessage", "RetryableError", "delay", "resolve", "startTime", "fileSize", "completeResponse", "isRetryable", "upload", "uploads", "addTypedEventListener", "target", "type", "handler", "uploadHandler", "UploadHandler", "handleMessage", "event", "data", "isWorkerInboundMessage", "broadcastLog", "message", "contentId", "error", "workerError", "addTypedEventListener"]
}
